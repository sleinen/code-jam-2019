;;; Google Code Jam 2019, Qualification Round, Problem 3: Cryptopangrams

(defun solve (&optional (in *standard-input*))
  (let ((ncases (read in)))
    (dotimes (caseno ncases)
      (solve-case caseno in))))

(defun solve-case (caseno in)
  (let ((N (read in))
	(L (read in)))
    (let ((ciph (make-array L)))
      (dotimes (k L)
	(let ((x (read in)))
	  (assert (<= x (* N N)))
	  (setf (aref ciph k) x)))
      (assert (= (length ciph) L))
      (let ((clearprimes (make-array (+ L 1))))
	(dotimes (k (- L 1))
	  (setf (aref clearprimes (+ k 1))
		(if (= (aref ciph k) (aref ciph (+ k 1)))
		    (sqrt (aref ciph k))
		    (gcd (aref ciph k) (aref ciph (+ k 1))))))
	(setf (aref clearprimes 0) (/ (aref ciph 0) (aref clearprimes 1)))
	(setf (aref clearprimes L) (/ (aref ciph (- L 1)) (aref clearprimes (- L 1))))
	(let ((sorted-primes
	       (sort (remove-duplicates (copy-seq clearprimes)) #'<))
	      (prime-to-char (make-hash-table :test #'eql))
	      (ch #\A))
	  (dotimes (k (length sorted-primes))
	    (let ((prime (aref sorted-primes k)))
	      (setf (gethash prime prime-to-char)
		    ch))
	    (setq ch (code-char (+ (char-code ch) 1))))
	  (format t "Case ~D: ~A~%"
		  (+ caseno 1)
		  (map 'string #'(lambda (x) (gethash x prime-to-char))
		       clearprimes)))))))
