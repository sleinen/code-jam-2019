(defpackage :gopher (:use :common-lisp))

(in-package :gopher)

(defun solve-with-streams (i o)
  (let* ((ncase (read i))
	 (n (read i))
	 (m (read i)))
    (catch 'solve-exit
      (dotimes (caseno ncase)
	(solve-case n m i o)))))

(defun solve (&optional setno)
  (if setno
      (let ((p (sb-ext:run-program "/usr/local/bin/python3" (list "testing_tool.py" (format nil "~D" setno))
				   :input :stream :output :stream :wait nil)))
	(assert p)
	(unwind-protect
	     (solve-with-streams
	      (sb-ext:process-output p)
	      (sb-ext:process-input p))
	  (sb-ext:process-close p)))
      (solve-with-streams *standard-input* *standard-output*)))

(defun solve-case (n m i o)
  (let ((sieve (make-array (list (+ m 1)) :element-type 'bit :initial-element 1)))
    (solve-case-1 n m i o sieve (+ m 1) '(18 17 16 15 13 11 7))))

(defun find-first-one (sieve)
  (dotimes (i (array-dimension sieve 0) nil)
    (when (not (zerop (aref sieve i)))
      (return i))))

(defun solve-case-1 (n m i o sieve left numbers)
  (declare (type (simple-array bit (*)) sieve))
  (if (= left 1)
      (let ((guess (find-first-one sieve)))
	(format o "~D~%" guess)
	(finish-output o)
	(let ((response (read i)))
	  (if (= response 1)
	      (warn "Guess ~D: Correct!" guess)
	      (warn "Guess ~D: We lose :-(" guess))))
      (let* ((blade (first numbers))
	     (blades (make-list 18 :initial-element blade)))
	(format o "~{~D~^ ~}~%" blades)
	(finish-output o)
	(let ((total 0))
	  (dotimes (track 18)
	    (incf total (read i)))
	  (dotimes (i total)
	    (when (not (zerop (aref sieve i)))
	      (decf left)
	      (setf (aref sieve i) 0)))
	  (do ((i total (+ i blade)))
	      ((> i m))
	    (do ((j 1 (+ j 1)))
		((or (> (+ i j) m) (>= j blade)))
	      (when (not (zerop (aref sieve (+ i j))))
		(decf left)
		(setf (aref sieve (+ i j)) 0))))
	  (warn "Answer: ~S left ~D" total left)
	  (solve-case-1 n m i o sieve left (rest numbers))))))

(solve)
