(defpackage :c (:use :common-lisp))

(in-package :c)

(defun solve (&optional (in *standard-input*))
  (let ((ncases (read in)))
    (declare (type (integer 1 100) ncases))
    (dotimes (caseno ncases)
      (solve-case caseno in))))

(defun solve-case (caseno in)
  (let ((N (read in))
	(K (read in)))
    (declare (type (integer 1 100000) N)
	     (type (integer 0 100000) K))
    (let ((cs (make-array (list N)
			  :element-type '(integer 0 100000)))
	  (ds (make-array (list N)
			  :element-type '(integer 0 100000))))
      (dotimes (i N) (setf (aref cs i) (read in)))
      (dotimes (i N) (setf (aref ds i) (read in)))
      (solve-case-1 caseno N K cs ds))))

(defun check-fair (N K i j cs ds)
  (declare (ignore N))
  (<= (abs (- (reduce #'max cs :start i :end (1+ j))
	      (reduce #'max ds :start i :end (1+ j))))
      K))

(defun solve-case-1 (caseno N K cs ds)
  (let ((fair-counter 0))
    (dotimes (i N)
      (do ((j i (+ j 1)))
	  ((>= j N))
	(when (check-fair N K i j cs ds)
	  (incf fair-counter))))
    (format t "Case #~D: ~D~%" (1+ caseno) fair-counter)))

(solve)
