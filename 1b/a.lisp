(defpackage :a (:use :common-lisp))

(in-package :a)

(defun solve (&optional (in *standard-input*))
  (let ((ncases (read in)))
    (dotimes (caseno ncases)
      (solve-case caseno in))))

(defun solve-case (caseno in)
  (let ((P (read in))
	(Q (read in)))
    (declare (type (integer 1 500) P)
	     (type (integer 1 100000) Q))
    (let ((points (list '() '()))
	  (+- (make-array (list 2))))
      (dotimes (axis 2)
	(setf (aref +- axis) (make-hash-table)))
      (labels
	  ((note-interval (start end axis)
	     (assert (<= start end))
	     (note-+- start axis +1)
	     (when (<= end Q) (note-+- end axis -1)))
	   (note-+- (point axis inc)
	     (unless (gethash point (aref +- axis))
	       (push point (elt points axis)))
	     (setf (gethash point (aref +- axis))
		   (+ (gethash point (aref +- axis) 0) inc)))
	   (max-index (points)
	     (car (reduce #'(lambda (x y)
			      (if (< (cdr x) (cdr y)) y x))
			  points
			  :initial-value '(0 . 0)))))
	(dotimes (k P)
	  (let ((x (read in)) (y (read in)) (dir (read in)))
	    (declare (type (integer 0 100000) x y))
	    (ecase dir
	      ((N) (note-interval (+ y 1) (+ Q 1) 1))
	      ((S) (note-interval 0 y 1))
	      ((E) (note-interval (+ x 1) (+ Q 1) 0))
	      ((W) (note-interval 0 x 0)))))
      (dotimes (axis 2)
	(setf (elt points axis)
	      (sort (elt points axis) #'<))
	(setf (elt points axis)
	      (let ((x 0))
		(mapcar #'(lambda (point)
			    (cons point
				  (incf x (gethash point (aref +- axis)))))
			(elt points axis)))))
      (format t "Case #~D:~{ ~D~}~%"
	      (+ caseno 1)
	      (mapcar #'max-index points))))))

(solve)
