(defpackage :a (:use :common-lisp))

(in-package :a)

(defun solve (&optional (in *standard-input*))
  (let ((ncases (read in)))
    (dotimes (caseno ncases)
      (solve-case caseno in))))

(defun solve-case (caseno in)
  (let ((P (read in))
	(Q (read in)))
    (declare (type (integer 1 500) P)
	     (type (integer 1 100000) Q))
    (let ((xdir (make-array (list (+ Q 1))
			    :element-type '(integer 0 500)
			    :initial-element 0))
	  (ydir (make-array (list (+ Q 1))
			    :element-type '(integer 0 500)
			    :initial-element 0))
	  (lists '((N ()) (S ()) (E ()) (W ()))))
      (dotimes (k P)
	(let ((x (read in))
	      (y (read in))
	      (dir (read in)))
	  (declare (type (integer 0 100000) x y))
	  (ecase dir
	    ((N S) (push y (getf lists dir)))
	    ((E W) (push x (getf lists dir))))))
      (dolist (dir '(N S E W))
	(let ((inc 0)
	      (mult (ecase dir ((N E) 1) ((S W) -1)))
	      (vec (ecase dir ((N S) ydir) ((E W) xdir))))
	  (do ((l (sort (getf lists dir) (ecase mult ((1) #'<) ((-1) #'>))) (rest l)))
	      ((endp l))
	    (incf inc)
	    (do ((k (+ (first l) mult) (+ k mult)))
		((if (= mult 1)
		     (or (> k Q) (> k (if (endp (rest l)) Q (second l))))
		     (or (< k 0) (< k (if (endp (rest l)) 0 (second l))))))
	      #+foo (warn "N: incf Y ~D by ~D" k inc)
	      (incf (aref vec k) inc)))))
      #+foo (warn "xdir ~A ydir ~A" xdir ydir)
      (format t "Case #~D: ~D ~D~%"
	      (+ caseno 1)
	      (position (reduce #'max xdir) xdir)
	      (position (reduce #'max ydir) ydir)))))

(solve)
