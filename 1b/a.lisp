(defpackage :a (:use :common-lisp))

(in-package :a)

(defun solve (&optional (in *standard-input*))
  (let ((ncases (read in)))
    (dotimes (caseno ncases)
      (solve-case caseno in))))

(defun solve-case (caseno in)
  (let ((P (read in))
	(Q (read in)))
    (let ((xdir (make-array (list (+ Q 2))
			    :element-type '(unsigned-byte 16)
			    :initial-element 0))
	  (ydir (make-array (list (+ Q 2))
			    :element-type '(unsigned-byte 16)
			    :initial-element 0)))
      (dotimes (k P)
	(let ((x (read in))
	      (y (read in))
	      (dir (read in)))
	  (declare (type (unsigned-byte 17) x y))
	  (ecase dir
	    ((N)
	     (do ((i (+ y 1) (+ i 1)))
		 ((> i Q))
	       ;;(warn "~D ~D ~A: incf Y ~D" x y dir i)
	       (incf (aref ydir i))))
	    ((S)
	     (do ((i 0 (+ i 1)))
		 ((>= i y))
	       ;;(warn "~D ~D ~A: incf Y ~D" x y dir i)
	       (incf (aref ydir i))))
	    ((E)
	     (do ((i (+ x 1) (+ i 1)))
		 ((> i Q))
	       ;;(warn "~D ~D ~A: incf X ~D" x y dir i)
	       (incf (aref xdir i))))
	    ((W)
	     (do ((i 0 (+ i 1)))
		 ((>= i x))
	       ;;(warn "~D ~D ~A: incf X ~D" x y dir i)
	       (incf (aref xdir i)))))))
      (format t "Case #~D: ~D ~D~%"
	      (+ caseno 1)
	      (position (reduce #'max xdir) xdir)
	      (position (reduce #'max ydir) ydir)))))

(solve)
